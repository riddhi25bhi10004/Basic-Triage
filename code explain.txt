The code is structured into four files to strictly adhere to the three major functional modules requirement, plus a configuration file for maintainability.

1. triage_rules.json (Configuration)

This file is a central repository for all the medical knowledge and risk thresholds.

1.1. symptom_weights: Assigns a baseline risk score (weight) to various symptoms.
1.2. severity_multipliers: Factors to increase the weight based on the user's reported severity (e.g., "severe" doubles the risk).
1.3. critical_rules: Defines combinations of symptoms (e.g., chest pain AND shortness of breath) that immediately trigger a "High Risk" alert, regardless of the overall calculated score.
1.4. triage_thresholds: Numerical scores that define the boundaries for the final risk level (e.g., Score > 15 is high risk).
1.5. recommendations: The clear, actionable output text for each risk level (meeting Usability).

2. input_module.py (Functional Module 1)

This module handles data acquisition and initial validation.

2.1. load_rules(): Reads and parses the `triage_rules.json` file. It includes a 'try...except' block for Error Handling if the file is missing or corrupted.
2.2. get_user_input():

 (a)Collects age and duration of symptoms with basic validation (e.g., age must be positive).
 (b)Iterates through the symptoms listed in the rules and prompts the user for the severity of each one.
 (c)If the user enters an invalid severity, it handles the error gracefully by logging a warning and skipping that symptom, ensuring the program doesn't crash.

3. triage_engine.py (Functional Module 2)

This is the core decision-making logic, prioritizing Performance

3.1. calculate_triage_score():
 (a) Critical Check: It first scans the user's symptoms against the critical_rules. If a match is found, it immediately returns a score of 100, ensuring immediate attention for life-threatening combinations.
 (b) Weighted Scoring: It loops through the reported symptoms, multiplies the symptom's weight by its severity multiplier, and adds the result to the total score.
 (c) Factor Adjustment: It adds small factors based on age or symptom duration (simplified logic).
 (d) Performance Measurement: It uses time.time() to measure the exact calculation duration (calc_time), allowing you to prove the < 1 second non-functional requirement is met.
 
3.2. determine_risk_level(): Compares the final numerical score against the thresholds defined in the rules file (low_risk, medium_risk) and returns a categorical risk level (LOW, MEDIUM, HIGH).

4. output_module.py (Functional Module 3)

This module handles the final communication with the user.

4.1. print_recommendation(): Takes the final risk level, score, and rules dictionary. It formats a clean, clear output banner and retrieves the pre-written actionable recommendation from the recommendations section of the JSON file, ensuring high Usability.

