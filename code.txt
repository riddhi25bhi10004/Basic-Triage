This code will be organized into the three functional modules and will incorporate concepts for error handling, performance measurement, and maintainability (using a configuration file for rules).

Python : Basic Symptom Checker

We'll use a rule-based approach and Python's built-in functionalities. We'll use a triage_rules.json file to store the rules, demonstrating Maintainability.

Project Structure:

symptom_checker/
├── main.py
├── input_module.py
├── triage_engine.py
├── output_module.py
└── triage_rules.json

1. triage_rules.json (Configuration File)

This file makes the logic easily maintainable.

{
    "symptom_weights": {
        "fever": 3.0,
        "shortness_of_breath": 5.0,
        "chest_pain": 6.0,
        "sore_throat": 1.0,
        "fatigue": 2.0
    },
    "severity_multipliers": {
        "mild": 1.0,
        "moderate": 1.5,
        "severe": 2.0
    },
    "critical_rules": [
        ["chest_pain", "shortness_of_breath"],
        ["shortness_of_breath", "severe"]
    ],
    "triage_thresholds": {
        "low_risk": 5.0,
        "medium_risk": 15.0
    },
    "recommendations": {
        "LOW": "Self-care and monitor symptoms. Contact a doctor if symptoms worsen.",
        "MEDIUM": "Schedule a routine appointment with your primary care physician soon.",
        "HIGH": "Seek immediate medical attention (Emergency Room or Urgent Care)."
    }
}


2. input_module.py (Functional Module 1)

This handles user interaction and basic validation.

import json

def load_rules():
    """Loads rules and weights from the JSON file."""
    try:
        with open('triage_rules.json', 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print("Error: triage_rules.json not found.")
        return None
    except json.JSONDecodeError:
        print("Error: Failed to parse triage_rules.json.")
        return None

def get_user_input(rules):
    """Collects symptom data from the user."""
    
    # 1. Collect Demographic Data
    try:
        age = int(input("Enter your age: "))
        if not 1 <= age <= 120:
            raise ValueError
        
        duration = int(input("How many days have you had symptoms? "))
        if duration < 0:
            raise ValueError
    except ValueError:
        print("\n**Error Handling:** Invalid age or duration input. Please try again.")
        return None

    patient_profile = {
        "age": age,
        "duration_days": duration,
        "symptoms": {}
    }

2. Collect Symptoms and Severity
    available_symptoms = rules['symptom_weights'].keys()
    print("\nPlease enter the severity (Mild, Moderate, Severe) for the following symptoms (or press Enter if absent):")
    
    for symptom in available_symptoms:
        severity = input(f"  {symptom} (Mild/Moderate/Severe): ").strip().lower()
        if severity in rules['severity_multipliers']:
            patient_profile['symptoms'][symptom] = severity
        elif severity:
            # Error Handling: Warn on bad severity input but continue
            print(f"Warning: '{severity}' is not a valid severity. Skipping {symptom}.")
            
    return patient_profile

if __name__ == '__main__':
    # Test loading rules
    rules = load_rules()
    if rules:
        print("Rules loaded successfully.")


3. triage_engine.py (Functional Module 2)

This performs the calculation and decision-making logic, focusing on Performance.

import time

def calculate_triage_score(profile, rules):
    """Calculates the Triage Score based on weighted rules."""
    
    start_time = time.time()
    score = 0.0

    # 1. Apply Critical Rules (Overrides)
    for rule in rules['critical_rules']:
        symptom1, symptom2 = rule
        if profile['symptoms'].get(symptom1) and profile['symptoms'].get(symptom2):
            # If critical combination found, set max score
            return 100.0, time.time() - start_time
    
    # 2. Score Individual Symptoms
    for symptom, severity in profile['symptoms'].items():
        weight = rules['symptom_weights'].get(symptom, 0.0)
        multiplier = rules['severity_multipliers'].get(severity, 1.0)
        
        score += weight * multiplier
        
    # 3. Apply Age and Duration Factors (Simplified)
    # Risk increases slightly with age > 65
    if profile['age'] > 65:
        score += 3.0
    
    # Risk increases slightly with long duration > 7 days
    if profile['duration_days'] > 7:
        score += 2.0
        
    end_time = time.time()
    
    # The performance metric: calculation time
    calculation_time = end_time - start_time
    
    return score, calculation_time

def determine_risk_level(score, rules):
    """Determines the risk level based on the calculated score."""
    
    thresholds = rules['triage_thresholds']
    
    if score >= thresholds['medium_risk']:
        return "HIGH"
    elif score >= thresholds['low_risk']:
        return "MEDIUM"
    else:
        return "LOW"

if __name__ == '__main__':
    # Mock data for testing Performance (should be < 1 second)
    mock_profile = {
        "age": 45,
        "duration_days": 3,
        "symptoms": {
            "fever": "moderate", 
            "fatigue": "severe", 
            "sore_throat": "mild"
        }
    }
    rules = {"symptom_weights": {"fever": 3.0, "fatigue": 2.0, "sore_throat": 1.0}, "severity_multipliers": {"mild": 1.0, "moderate": 1.5, "severe": 2.0}, "triage_thresholds": {"low_risk": 5.0, "medium_risk": 15.0}} # Simplified rules
    score, t = calculate_triage_score(mock_profile, rules)
    
print(f"Calculated Score: {score:.2f}")
print(f"Risk Level: {determine_risk_level(score, rules)}")
print(f"Calculation Time: {t:.6f} seconds (Target: < 1.0s)")


4. output_module.py (Functional Module 3)

This translates the risk level into an actionable recommendation, focusing on Usability.

def print_recommendation(risk_level, score, rules):
    """Prints the final recommendation to the user."""
    
    print("\n" + "="*50)
    print(f"*** Triage Assessment Result ***")
    print(f"Risk Level: **{risk_level}**")
    print(f"Calculated Score: {score:.2f}")
    print("-" * 50)
    
    # Use the predefined text from the rules for clear, consistent output
    recommendation = rules['recommendations'].get(risk_level, "Assessment inconclusive. Contact a professional.")
    
    print(f"Recommendation:\n{recommendation}")
    print("="*50)

5. main.py (Execution)

This brings all the modules together.

import input_module
import triage_engine
import output_module

def run_symptom_checker():
    """Main function to run the symptom checker workflow."""
    
    rules = input_module.load_rules()
    if not rules:
        return # Exit if rules couldn't load (Error Handling)

    # 1. Get Input
    profile = input_module.get_user_input(rules)
    if not profile:
        print("Triage process cancelled due to input error.")
        return # Exit if input was invalid

    # 2. Calculate Score (Performance Test)
    score, calc_time = triage_engine.calculate_triage_score(profile, rules)
    
    print(f"\n[Performance Check: Calculation completed in {calc_time:.6f} seconds]")
    if calc_time > 1.0:
        print("WARNING: Calculation time exceeded 1.0 second non-functional requirement.")
    
    # 3. Determine Risk
    risk_level = triage_engine.determine_risk_level(score, rules)

    # 4. Print Output (Usability)
    output_module.print_recommendation(risk_level, score, rules)
    
if __name__ == '__main__':
    run_symptom_checker()